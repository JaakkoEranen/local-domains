const fs = require('fs');
const apacheConfigPath = '/etc/apache2/other/local-domains.conf';
const httpdConfigPath = '/etc/apache2/httpd.conf';
const hostsPath = '/etc/hosts';

const parseApacheConfigForDomainsAndPorts = () => {
    return new Promise((resolve, reject) => {
      fs.readFile(apacheConfigPath, { encoding: 'utf-8' }, (err, data) => {
        if (err) {
          reject(err);
          return;
        }
  
        const virtualHostRegex = /<VirtualHost \*:80>[\s\S]*?ServerName (\S+)[\s\S]*?ProxyPass \/ http:\/\/127\.0\.0\.1:(\d+)\/[\s\S]*?<\/VirtualHost>/g;
  
        let matches;
        const domainsAndPorts = [];
        
        while ((matches = virtualHostRegex.exec(data)) !== null) {
          const domain = matches[1];
          const port = parseInt(matches[2], 10);
  
          domainsAndPorts.push({ domain, port });
        }
  
        resolve(domainsAndPorts);
      });
    });
}

const ensureHostsFileComments = async () => {
    try {
        let hostsContent = await fs.promises.readFile(hostsPath, { encoding: 'utf-8' });
        const startComment = "# Below are the domains generated by the Local Domains application";
        const endComment = "# End of the domains generated by the Local Domains application";

        if (!hostsContent.includes(startComment) && !hostsContent.includes(endComment)) {
            const comments = `\n${startComment}\n${endComment}\n`;
            return `echo -e '${comments.replace(/'/g, "'\\''")}' | sudo tee -a ${hostsPath}`;
        } else {
            console.log('Hosts file already contains the necessary comments.');
            return '';
        }
    } catch (error) {
        console.error('Error generating command for updating the hosts file:', error);
        return '';
    }
};

const init = async () => {
    let commands = [];

    try {
        let httpdConfigContent = await fs.promises.readFile(httpdConfigPath, { encoding: 'utf-8' });
        let modified = false;
        const proxyModuleRegex = /^#LoadModule proxy_module libexec\/apache2\/mod_proxy.so/m;
        const proxyHttpModuleRegex = /^#LoadModule proxy_http_module libexec\/apache2\/mod_proxy_http.so/m;

        if (proxyModuleRegex.test(httpdConfigContent)) {
            httpdConfigContent = httpdConfigContent.replace(proxyModuleRegex, 'LoadModule proxy_module libexec/apache2/mod_proxy.so');
            modified = true;
        }

        if (proxyHttpModuleRegex.test(httpdConfigContent)) {
            httpdConfigContent = httpdConfigContent.replace(proxyHttpModuleRegex, 'LoadModule proxy_http_module libexec/apache2/mod_proxy_http.so');
            modified = true;
        }

        if (modified) {
            const tempFilePath = '/tmp/httpdConfig.tmp';
            await fs.promises.writeFile(tempFilePath, httpdConfigContent, { encoding: 'utf-8' });

            commands.push(`cp ${tempFilePath} ${httpdConfigPath}`);
            commands.push('rm /tmp/httpdConfig.tmp')
        }
    } catch (error) {
        console.error('Error modifying httpd.conf:', error);
    }

    try {
        await fs.promises.access(apacheConfigPath, fs.constants.F_OK);
    } catch (err) {
        commands.push(`sudo touch ${apacheConfigPath}`);
    }

    return commands
}


module.exports = { init, parseApacheConfigForDomainsAndPorts, ensureHostsFileComments };
